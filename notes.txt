https://spin.atomicobject.com/2016/06/26/parallelize-development-git-worktrees/
  >>> FOR NOW, running this project in parallel JS & TS branches



body
  main
  header
    Y title
    Y click-to-copy
  options
    Y textarea
    Y add-me
    Y dice roller input & fill-in
    Y toggle: traits ideals bonds flaws trinkets 
    quirks
    fold menu for background & source selection
    trait-searchbar (& selection popup)
  characteristics
    Y text editable
    Y remove
    Y drag handle
    label for type (small font, ideal bond etc...)


vim config for vscode https://www.youtube.com/watch?v=Vkm4bc2Y0AA
  https://mail.google.com/mail/u/0/#inbox/FMfcgzGqRZlvKwlvprrZQfCLwmKLRcXq


TODO APP
  favicon
  add all the personality stuff!
  absolute import paths? (eg: https://adamrackis.dev/blog/css-modules)
    https://medium.com/@etherealm/getting-rid-of-relative-paths-in-imports-using-webpack-alias-78d4bf15bb42
  
  accessibility
    form for main options
    remove should be a button for access

TODO BONUS FEATURES for TYPESCRIPT
  tag list for each item (add, remove, edit) for category, background, source
  foldable background list for backgrounds & sources


      
TODO LIB
  add multiple callbacks for register
    UNregister?m (return a reference to the function, and search for that?)
      ooh, return the unsubscribe function! (see jsmanifest)
  LOOKOUT component render is called before component constructor
    because the parent construtor (super) is called first!

TODO study
  review the flow of "this" definitions in a method like charInput


WEBPACK
  https://stackoverflow.com/questions/36039146/webpack-dev-server-compiles-files-but-does-not-refresh-or-make-compiled-javascri 
  removed open,  "serve": "webpack serve --open",



CONVENTIONS
  DOMThing for anything js variable that is a DOM element...

  char vs characteristics
    "characteristic(s)" as state field,
    "char" abbreviation for other uses (component, element, css, method)

  snake-case in css (class/id), camelCase for javascript (varibles / object key names)

  CSS approach:
    all styles to follow component and js names by convention
      CHILD STYLE NAMING PROS & CONS
        (ie .char-item .char-item-left vs .char-item .left )
          simpler version is easier to maintain (long names are a lot to manage)
          > but note that you want to keep names in sync between JS & CSS...
          ALso you'll want to test eg ".left" in two different components


Patterns (not necessarily used here):
  https://jsmanifest.com/the-publish-subscribe-pattern-in-javascript/
  https://betterprogramming.pub/chaining-patterns-in-javascript-df05e3030ee7
  https://javascript.plainenglish.io/javascript-design-patterns-the-decorator-pattern-eaf6adc77cb7
  https://medium.com/geekculture/dependency-injection-in-javascript-2d2e4ad9df49




LINTING
  > might be worth just experimenting with eslint for a bit before u add prettier...


Simplistic framework
    ðŸ¤£ "User decorators for something"

    ?? maybe what you want here is "register" - something that connects a certain value with state, and receives updates...?

    https://stackoverflow.com/questions/56037261/how-to-rerender-single-element-of-a-web-component
    HTML machine... eg: https://www.youtube.com/watch?v=hYCqhdJiAxM
    state management
    flexible render method (use a templating library?)
    wrapper for listener assignment (to update state)
    trigger to render on state update (triggers?)
      PROBLEM is that reRender (as rebuilding DOM) causes inputs to loose focus
        (ie: it's not just a performance issue)
        even autofocus probably won't work - cursor position is prob internal state of the field
      SO it's a bad approach to automatically re-build on state field changes
      best to only call rebuild when you need it
      what you might could do is to still register callbacks based on state field changes though
        (would be nice to define these internally for each component)
        so eg: in "Characteristic" component your callback updates the field value
        (note that this requires using array/object overwrites every time...)
        (see notes about reg in component.js)
      BUT, there may still need to be a distinction between "events in general" and "state updates"
        example:
          AddMe button - this can rebuild the list because loss of focus at that time is ok
          vs updating (via contenteditable) the text of an item in the list
          both will setState('characteristics', [...newCharacteristics])
          so the pubsub system will have to develop there
            expand current methods? or use separate methods for stateField and general?
            probably separate, because current setState calls registered items EVERY TIME
              (?...are there things that you reliably want to do that with?
                having the hook there is a neat idea (as a feature) but not clear if it will be used...
        but for starters let's try them in the same and see what happens...
        BTW you'll want to register an array of funtions (same event can call multiple things)
      ...it may take a while (even to end of project) to know how/whether you're going to use
        the setState auto-publish & component auto-register features
        let's keep them in for how and watch how the rest of this builds
      > one reason it might be better to have them separate is that
          you might accidentally register a key which also a stateField
          so better to have to explicitly register the kye twice for something that you do want to do that

        EXAMPLES
          >>> currently setState autoPublish is used for mainInput

    Hmm:
      "would be cool to use method chaining here: const mainInput = build(...).register(...)"


    // IS THERE ANY REAL NEED to then programatically set the input?
    // essentially you are keeping state updated for persistence


TODO babel experiment
    doc tho https://babeljs.io/docs/en/
    try to ID some features which are/aren't present
      like what are some advanced features that aren't in browsers yet?
    study: what features from what releases?
      https://www.odinschool.com/blog/programming/java-script-versions#:~:text=ES5%20was%20released%20in%202009,release%20of%20its%20previous%20version.
    fyi: https://babeljs.io/docs/en/babel-preset-typescript








TODO study:
  - VSCode why does search with src include node_modules?
  - Study TypeScript & DOM
      https://www.typescriptlang.org/docs/handbook/dom-manipulation.html
      difference between children and childNodes?
  - am I using the term 'declarative' correctly?
      https://alexsidorenko.com/blog/react-is-declarative-what-does-it-mean/
      https://stackoverflow.com/questions/33655534/difference-between-declarative-and-imperative-in-react-js


  CSS MODULES links if you want to do it the webpack way...
    https://blog.logrocket.com/how-to-configure-css-modules-webpack/
    https://blog.jakoblind.no/css-modules-webpack/
    https://css-tricks.com/css-modules-part-1-need/
    https://adamrackis.dev/blog/css-modules

  
  user-select vs contenteditable
    https://stackoverflow.com/questions/4777860/highlight-select-multiple-divs-with-ranges-w-contenteditable
    might need to make your own ranges: https://javascript.info/selection-range


*** Personalities *********************************************************
    dndbeyond.com/sources/basic-rules/personality-and-background
    http://weirdzine.com/wp-content/uploads/2015/09/Personality-Traits.pdf
    https://mykindofmeeple.com/dnd-personality-traits/
    http://weirdzine.com/wp-content/uploads/2015/09/Ideals.pdf
    


*** HELPERS ***
function removeAllChildNodes(parent) {
  while (parent.firstChild) {
      parent.removeChild(parent.firstChild);
  }
}


BROKEN IMAGE FROM
  https://icon-library.com/icon/20-sided-dice-icon-8.html



*** TS FYI ****************************************************************************************

// let verbList: string[][] = [];
// let verbList: Array<string>[] = [];

// For CDN use:
// https://stackoverflow.com/questions/12709074/how-do-you-explicitly-set-a-new-property-on-window-in-typescript
  declare global { interface Window { dragula: any; } }
  const verbsDrake = dragula([DOMVerbList, DOMTrash], {
      removeOnSpill: false,
  });

  // https://medium.com/@jeffbutsch/typescript-interface-functions-c691a108e3f1
  // https://www.tutorialsteacher.com/typescript/typescript-interface
  // https://medium.com/geekculture/html-event-handling-in-typescript-b9ca7178d912
    onClick?(): void, // Type '(e: Event) => void' is not assignable to type '() => void'
    // onClick?(arg0: Event): void, // but this works
    // onClick?: (arg0: Event) => void, // so does this
    const mainInput = build(options, 'input', {className: 'main-input', onClick: listenerTest});

  Object key typing:
    https://bobbyhadz.com/blog/typescript-element-implicitly-has-any-type-expression
    https://bobbyhadz.com/blog/typescript-type-string-is-not-assignable-to-type#:~:text=The%20%22Type%20'string'%20is,const%20or%20a%20type%20assertion.






*** DOM ***
  https://oozou.com/til/create-element-with-attributes-in-one-line-69





*** RESOURCES ****************************************************************************************
  https://game-icons.net/


*** MYSTERIES ****************************************************************************************
    - something added extra .js files alongside .ts files
        https://stackoverflow.com/questions/63422959/webpack-build-or-typescript-is-creating-js-files-right-in-my-src
        what's weird is that it doesn't do this on build
            not sure exactly when/why these files are created
        also maybe u didn't want to get rid of them
            tsconfig has "target": "es5", and it's interesting,
              eg ListTemplate.js used an iife

*** MYSTERIES (solved) ****************************************************************************************
  main input not clearing wtf. it breaks between these commits:
    3249459 basic individual components without reactivity
    3665b82 addMe button and list with call to render
      https://stackoverflow.com/questions/29929797/setattribute-doesnt-work-the-way-i-expect-it-to
      https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html


  

*** AUTO-REGISTER THINKING ***
  // WIP...
  registered() {
    return [];
  }

  // WIP...
  // ... SO call to render here is bad, but this might be the place where you reg the callbacks
  // ie: you could assign them with a dictionary/dispatch table on the specific component,
  // and then hook them into global state here
  register() {
    this.registered().forEach((e) => {
      // reg(e, () => this.render());
      reg(e, () => console.info("component-registered callback:", e));
    });
  }



****************************************************************************************
js-store branch THINKING
  is this dependency injection? https://medium.com/geekculture/dependency-injection-in-javascript-2d2e4ad9df49
  lib structure
    call it store instead of state, rebuild instead of render
    persist
    scope/module for state & registration (hmm iirc "file state" is an antipattern, perhaps you'll accidentally do that...)
      (probably you'll apply calls to base Component)
      (but shouldn't you be wrapping everything in a thing or something?)
        sure, a Class probably
      so currently you're: 
        1 - initialize store methods as class (pass in state)
        2 - passing it as a prop to the root component
        and that's it. Should work.
        Something is not quite satisfying though.
        It seems like there should be an official ("Setup") call
          distinct from the creation of a component
        and though you're blocking duplication it still feels kind of flimsy
          for one you can still overwrite this.store in a sub componenet
          (can you do a readonly?)
          and it's somehow arbitrary

        wanting something like:
          state = {stuff: stuff}
          const app = new App(DOMRoot, 'div');
          const myLibrary = new MyLibrary()
          myLibrary.initStore(state)
          myLibrary.initTopComponent(app)
        ... this is nice but note that currently new App calls render...
        
        how about:
          import { myLibrary }
          import App
          state = {stuff: stuff}
          // const app = new App(DOMRoot, 'div');
          const myLibrary = new MyLibrary()
          myLibrary.initStore(state)
          myLibrary.initTopComponent(DOMRoot, App, 'div')
            then this method appends the store to the top level
            this.store can still be overwritten, 
            but it does limit the arbitrariness and prevent the store duplication attempt
          MyLibrary could store the various things;
            build
            component
            store
          ... also, appending a store to an instance only sets it up for that one instance...
        
        OR
          better yet let's treat the component system and the store/pubsub system separate libraries
          import { Component, Store } from foolsGold
          import App from './App'
          const initialStore = { stuff: stuff } 
          const store = new Store(initialStore)
          const app = new App
          app.initStore(store) 
            ... nowyour issue here is that the auto-render in init will crash it if the store isn't there already
            what you want is to have to call app.render to kick it off
            so how do you differentiate between the "top" component which doesn't auto-render, and the rest, which do?
            you could have a flag in the Component base, "isSetup", to check if it's auto-called
              but then that flag has to be tripped for each component
            SO yeah maybe you do need a separate over-system to call your component tree and hold the store reference
              still how do you actually access the store reference from within the components?
                chicken/egg situation here, where you can't attach a reference to an uninstantiated class,
                but instantiating the class without access to store causes it to crash
              is there a way to automatically send things into the constructors?
                like a wrapper which calls new Thing

        VUE:
          const app = createApp(App).use(store)
          app.mount("#app");

          maybe: 
            - nothing starts to render until .mount is called
            - setup prior has a wrapper for new (thing) which passes in store
            OK: your problem is that components are instantiated during render
              so that means, if you want to programatically pass in something 
                (during instantiation or append to instantiation)
                you need to instantiate components BEFORE they render
                SO you can also do that Vue-style, 
                  where you name the used components at the top,
                  then in your render body you can call a method on them to get them to each render
                  oof. rendering CharItems tho ðŸ˜­

        Some luck with referencing store instance in Component,
          see index.js
          I think that's "file state" though


        Seo: the Vue approach is the builder pattern: https://refactoring.guru/design-patterns/builder
          see first code snippet in "Structure"
          ("Vue uses the builder pattern with a "fluent interface") fluent interface == method chaining